<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Extractor.js - Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Extractor.html">Extractor</a><ul class='methods'><li data-type='method'><a href="Extractor.html#addLuaPath">addLuaPath</a></li><li data-type='method'><a href="Extractor.html#clearLoadedPackages">clearLoadedPackages</a></li><li data-type='method'><a href="Extractor.html#extract">extract</a></li><li data-type='method'><a href="Extractor.html#filterFields">filterFields</a></li><li data-type='method'><a href="Extractor.html#getLuaPath">getLuaPath</a></li><li data-type='method'><a href="Extractor.html#setLuaPath">setLuaPath</a></li></ul></li><li><a href="Mod.html">Mod</a><ul class='methods'><li data-type='method'><a href="Mod.html#.loadFromManifest">loadFromManifest</a></li><li data-type='method'><a href="Mod.html#.loadFromZip">loadFromZip</a></li><li data-type='method'><a href="Mod.html#.versionGreater">versionGreater</a></li><li data-type='method'><a href="Mod.html#addCleanup">addCleanup</a></li><li data-type='method'><a href="Mod.html#cleanup">cleanup</a></li><li data-type='method'><a href="Mod.html#dependsOn">dependsOn</a></li><li data-type='method'><a href="Mod.html#parseDependencies">parseDependencies</a></li><li data-type='method'><a href="Mod.html#satisfiesDependency">satisfiesDependency</a></li></ul></li><li><a href="ModuleLoader.html">ModuleLoader</a><ul class='methods'><li data-type='method'><a href="ModuleLoader.html#added">added</a></li><li data-type='method'><a href="ModuleLoader.html#all">all</a></li><li data-type='method'><a href="ModuleLoader.html#enabled">enabled</a></li><li data-type='method'><a href="ModuleLoader.html#parseOpts">parseOpts</a></li><li data-type='method'><a href="ModuleLoader.html#sortedDependencies">sortedDependencies</a></li><li data-type='method'><a href="ModuleLoader.html#vanilla">vanilla</a></li></ul></li></ul><h3>Global</h3><ul><li><a href="global.html#camelCase">camelCase</a></li><li><a href="global.html#DependencyType">DependencyType</a></li><li><a href="global.html#objMap">objMap</a></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">Extractor.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>const Promise = require("bluebird");
const fs = require("fs-extra");
const path = require("path");
const ModuleLoader = require("./ModuleLoader");
const nodelua = require("nodelua");

/**
 * `Array.map()` for objects.  Walks through each property in the object and creates an object after running each key
 * through `cb`.
 * @param {Object} obj the object to iterate through.
 * @param {Function} cb called for each property in `obj`.  Return `undefined` to remove a key.  Otherwise, the returned
 *   value will be added to the output object under the same key.
 * @return {Object} The result of running each property in `obj` through `cb`.
 * @todo Move to a static method or seperate file.
 * @todo Write unit tests.
*/
function objMap(obj, cb) {
  let out = {};
  for(var k in obj) {
    if(!obj.hasOwnProperty(k)) { continue; }
    val = cb(k, obj[k], obj);
    if(val !== undefined) { out[k] = val; };
  }
  return out;
}

/**
 * Creates a camel-cased version of a string.
 * @param {String} str the incoming text
 * @return {String} a camel-cased version of the string.
 * @todo Move to a static method or seperate file.
 * @todo Write unit tests.
*/
function camelCase(str) {
  return str.replace(/([-_][a-zA-Z])/g, (s) => s[1].toUpperCase());
}

/**
 * Extracts data from a Factorio save.
*/
class Extractor {

  /**
   * A script that shims Factorio core utilities.
   * Adapted from Foreman's
   * {@link https://bitbucket.org/Nicksaurus/foreman/src/46053df/Foreman/DataCache.cs#DataCache.cs-103|DataCache.cs}
   * @type {String}
   * @private
  */
  static get utilScript() {
    return `
      function module(modname, ...)
      end

      require "util"
      util = {}
      util.table = {}
      util.table.deepcopy = table.deepcopy
      util.multiplystripes = multiplystripes

      data.raw["gui-style"] = {}
      data.raw["gui-style"]["default"] = {}`;
  }

  /**
   * The Lua scripts that contain data information.
   * @type {Array&lt;String>}
  */
  static get dataFiles() {
    return this._dataFiles || [
      "data.lua",
      "data-updates.lua",
      "data-final-fixes.lua",
    ];
  }

  //static set dataFiles(files) { this._dataFiles = files; }

  /**
   * The different categories of items in Factorio.
   * @type {Array&lt;String>}
  */
  static get itemTypes() {
    return ["item", "fluid", "capsule", "module", "ammo", "gun", "armor", "blueprint", "deconstruction-item",
     "mining-tool", "repair-tool", "tool"];
   }

   static get dataTypes() {
     return ["recipe", "assembling-machine", "furnace", "mining-drill", "resource", "module"];
   }

  /**
   * @param {String} gamePath the path to the Factorio directory - contains "mods", "config", "data", etc.
   * @param {String} output the target output directory to dump a JSON of the Factorio data into.
   * @todo Write unit tests.
  */
  constructor(gamePath, output) {
    this.gamePath = gamePath;
    this.output = output || path.join(__dirname, "_extracted.json");
    this.lua = Promise.promisifyAll(new nodelua.LuaState('lua'));
    this._mods = [];
  }

  /**
   * Extract all of the game data, and save into a `json` file.
   * @return {Promise} resolves once all tasks have been run.
   * @todo Include list of mods in output.
   * @todo Parse images linked by resources, and (optionally) load them into the data.
  */
  extract() {
    let basePath;
    let lualib = path.join(this.gamePath, "data", "core", "lualib");
    let dataloader = path.join(lualib, "dataloader.lua");
    let moduleLoader = new ModuleLoader({ factorioPath: this.gamePath });
    return Promise.resolve()
      .then(() => this.addLuaPath(lualib))
      .then(() => this.getLuaPath())
      .then(path => basePath = path)
      .then(() => this.lua.doFileAsync(dataloader))
      .then(() => this.lua.doStringAsync(this.constructor.utilScript))
      .then(() => moduleLoader.enabled())
      .then(mods => moduleLoader.sortedDependencies(mods))
      .then(mods => {
        this._mods = mods;
        this._luaErrors = 0;
        let task = Promise.resolve();
        for(const dataFile of this.constructor.dataFiles) {
          console.log(`Running ${dataFile}`);
          for(const mod of mods) {
            let scriptPath = path.join(mod.dir, dataFile);
            task = task
              .then(() => this.setLuaPath(basePath))
              .then(() => this.addLuaPath(mod.dir))
              .then(() => this.clearLoadedPackages())
              .then(() => fs.readFile(scriptPath, "utf8"))
              .then((script) => this.lua.doStringAsync(script))
              .catch({code: 'ENOENT'}, (e) => { return true; })
              .catch((e) => {
                this._luaErrors++;
                console.log(e.message);
                console.log("Continuing.");
                return true;
              });
          }
        }
        return task;
      })
      .then(() => console.log(`Ignorning ${this._luaErrors} Lua errors.`))
      .then(() => {
        const raw = this.lua.getGlobal("data").raw;
        let data = {
          items: {},
        };
        for(const type of this.constructor.itemTypes) {
          data.items[type] = this.filterFields(raw[type], { type: type, subgroup: type });
        }
        for(const type of this.constructor.dataTypes) {
          data[camelCase(type)+"s"] = this.filterFields(raw[type], { type: type });
        }
        return data;
      })
      .then(data => fs.writeFile(this.output, JSON.stringify(data)))
      .finally(() => Promise.all(this._mods.map(mod => mod.cleanup())));
  }

  /**
   * Add a path to the Lua package lookup.
   * @param {String} addition the Lua source file, without a file extension.
   * @return {Promise} resolves when the path has been added to the current Lua scope.
   * @todo Write unit tests.
  */
  addLuaPath(addition) {
    return this.lua.doStringAsync(`package.path = package.path .. ';${addition}/?.lua'`);
  }

  /**
   * Set the Lua path.
   * @param {String} path the new package path.
   * @return {Promise} resolves when the Lua path has been set.
   * @todo Write unit tests.
  */
  setLuaPath(path) {
    this.lua.setGlobal("package.path", path);
    return Promise.resolve();
  }

  /**
   * Get the current Lua path.
   * @return {Promise&lt;String>} the current Lua package path.
   * @todo Write unit tests.
  */
  getLuaPath() {
    return Promise.resolve(this.lua.getGlobal("package.path"));
  }

  /**
   * Because many mods use the same path to refer to different files, we need to clear the 'loaded' table so Lua doesn't
   * think they're already loaded
   * @return {Promise} resolves when all packages have been cleared.
   * @todo Write unit tests.
  */
  clearLoadedPackages() {
    return this.lua.doStringAsync(`
      for k, v in pairs(package.loaded) do
        package.loaded[k] = false
      end`);
  }

  /**
   * Filters out repetitive fields to reduce the file output size.
   * @param {Object} obj the object to filter
   * @param {Object} filters fields to filter out.  `{&lt;key>: &lt;value>}` any keys matching `key` will be checked against
   *   `value`.  If `value` is a string and matches, then the key/value will be deleted from `obj`.  If `value` is a
   *   function, it will be provided the current value in the object, and it's return value will be used as the new
   *   value in `obj`.  Return `undefined` to delete the property from `obj`.
   * @return {Object} `obj` after the filters have been executed.
   * @todo Write unit tests.
  */
  filterFields(objs, filters) {
    return objMap(objs, (i, item) => {
      return objMap(item, (k, v) => {
        if(k === "name" &amp;&amp; v === i) { return undefined; }
        if(typeof filters[k] === "string" &amp;&amp; v === filters[k]) { return undefined; }
        if(typeof filters[k] === "function") { return filters[k](v); }
        return v;
      });
    });
  }

}

module.exports = Extractor;
</code></pre>
        </article>
    </section>




</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.3</a> on Sat Jun 10 2017 17:42:57 GMT+0000 (UTC) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
</body>
</html>
